// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-product/internal/sdk/internal/utils"
)

// Description - Name of the extension.
type Description struct {
	AdditionalProperties map[string]string `additionalProperties:"true" json:"-"`
	// Name of the extension in English.
	En string `json:"en"`
}

func (d Description) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *Description) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"en"}); err != nil {
		return err
	}
	return nil
}

func (o *Description) GetAdditionalProperties() map[string]string {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *Description) GetEn() string {
	if o == nil {
		return ""
	}
	return o.En
}

type SchemasExtensionHookMeterReadingPlausibilityCheckCall struct {
	// JSON body to use for the call. Supports variable interpolation.
	Body map[string]string `json:"body"`
	// Headers to use. Supports variable interpolation.
	Headers map[string]string `json:"headers"`
	// URL to call. Supports variable interpolation.
	URL string `json:"url"`
}

func (s SchemasExtensionHookMeterReadingPlausibilityCheckCall) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SchemasExtensionHookMeterReadingPlausibilityCheckCall) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"body", "headers", "url"}); err != nil {
		return err
	}
	return nil
}

func (o *SchemasExtensionHookMeterReadingPlausibilityCheckCall) GetBody() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Body
}

func (o *SchemasExtensionHookMeterReadingPlausibilityCheckCall) GetHeaders() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Headers
}

func (o *SchemasExtensionHookMeterReadingPlausibilityCheckCall) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

// SchemasExtensionHookMeterReadingPlausibilityCheckResolved - Response to the call
type SchemasExtensionHookMeterReadingPlausibilityCheckResolved struct {
	// Lower allowed limit of the meter reading
	LowerLimit *string `json:"lower_limit,omitempty"`
	// Upper allowed limit of the meter reading
	UpperLimit *string `json:"upper_limit,omitempty"`
	// Indicate whether the meter reading is plausible
	Valid *string `json:"valid,omitempty"`
}

func (s SchemasExtensionHookMeterReadingPlausibilityCheckResolved) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SchemasExtensionHookMeterReadingPlausibilityCheckResolved) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *SchemasExtensionHookMeterReadingPlausibilityCheckResolved) GetLowerLimit() *string {
	if o == nil {
		return nil
	}
	return o.LowerLimit
}

func (o *SchemasExtensionHookMeterReadingPlausibilityCheckResolved) GetUpperLimit() *string {
	if o == nil {
		return nil
	}
	return o.UpperLimit
}

func (o *SchemasExtensionHookMeterReadingPlausibilityCheckResolved) GetValid() *string {
	if o == nil {
		return nil
	}
	return o.Valid
}

type SchemasExtensionHookMeterReadingPlausibilityCheckType string

const (
	SchemasExtensionHookMeterReadingPlausibilityCheckTypeMeterReadingPlausibilityCheck SchemasExtensionHookMeterReadingPlausibilityCheckType = "meterReadingPlausibilityCheck"
)

func (e SchemasExtensionHookMeterReadingPlausibilityCheckType) ToPointer() *SchemasExtensionHookMeterReadingPlausibilityCheckType {
	return &e
}
func (e *SchemasExtensionHookMeterReadingPlausibilityCheckType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "meterReadingPlausibilityCheck":
		*e = SchemasExtensionHookMeterReadingPlausibilityCheckType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SchemasExtensionHookMeterReadingPlausibilityCheckType: %v", v)
	}
}

// ExtensionHookMeterReadingPlausibilityCheckSchemas - Hook that checks the plausibility of meter readings before they are saved. This hook makes a POST call whenever a user is trying to save a meter reading. The expected response to the call is:
//
//   - 200:
//     If meter reading is plausible, the response should contain:
//   - valid: true
//     If meter reading is not plausible, the response should contain:
//   - valid: false
type ExtensionHookMeterReadingPlausibilityCheckSchemas struct {
	Auth *ExtensionAuthBlock                                   `json:"auth,omitempty"`
	Call SchemasExtensionHookMeterReadingPlausibilityCheckCall `json:"call"`
	// Identifier of the hook. Should not change between updates.
	ID *string `json:"id,omitempty"`
	// Response to the call
	Resolved SchemasExtensionHookMeterReadingPlausibilityCheckResolved `json:"resolved"`
	Type     SchemasExtensionHookMeterReadingPlausibilityCheckType     `json:"type"`
}

func (e ExtensionHookMeterReadingPlausibilityCheckSchemas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ExtensionHookMeterReadingPlausibilityCheckSchemas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"call", "resolved", "type"}); err != nil {
		return err
	}
	return nil
}

func (o *ExtensionHookMeterReadingPlausibilityCheckSchemas) GetAuth() *ExtensionAuthBlock {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ExtensionHookMeterReadingPlausibilityCheckSchemas) GetCall() SchemasExtensionHookMeterReadingPlausibilityCheckCall {
	if o == nil {
		return SchemasExtensionHookMeterReadingPlausibilityCheckCall{}
	}
	return o.Call
}

func (o *ExtensionHookMeterReadingPlausibilityCheckSchemas) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *ExtensionHookMeterReadingPlausibilityCheckSchemas) GetResolved() SchemasExtensionHookMeterReadingPlausibilityCheckResolved {
	if o == nil {
		return SchemasExtensionHookMeterReadingPlausibilityCheckResolved{}
	}
	return o.Resolved
}

func (o *ExtensionHookMeterReadingPlausibilityCheckSchemas) GetType() SchemasExtensionHookMeterReadingPlausibilityCheckType {
	if o == nil {
		return SchemasExtensionHookMeterReadingPlausibilityCheckType("")
	}
	return o.Type
}

type SchemasExtensionHookCostDataRetrievalCall struct {
	// Request body to send. Supports variable interpolation. Content format is determined by Content-Type header.
	Body map[string]string `json:"body,omitempty"`
	// Headers to use. Supports variable interpolation.
	Headers map[string]string `json:"headers,omitempty"`
	// HTTP method to use for the call
	Method *string `default:"GET" json:"method"`
	// Parameters to append to the URL. Supports variable interpolation.
	Params map[string]string `json:"params,omitempty"`
	// URL to call. Supports variable interpolation.
	URL string `json:"url"`
}

func (s SchemasExtensionHookCostDataRetrievalCall) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SchemasExtensionHookCostDataRetrievalCall) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"url"}); err != nil {
		return err
	}
	return nil
}

func (o *SchemasExtensionHookCostDataRetrievalCall) GetBody() map[string]string {
	if o == nil {
		return nil
	}
	return o.Body
}

func (o *SchemasExtensionHookCostDataRetrievalCall) GetHeaders() map[string]string {
	if o == nil {
		return nil
	}
	return o.Headers
}

func (o *SchemasExtensionHookCostDataRetrievalCall) GetMethod() *string {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *SchemasExtensionHookCostDataRetrievalCall) GetParams() map[string]string {
	if o == nil {
		return nil
	}
	return o.Params
}

func (o *SchemasExtensionHookCostDataRetrievalCall) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

type SchemasResolved struct {
	// Optional path to the data (array) in the response. If omitted, the data is assumed to be on the top level.
	DataPath *string `json:"dataPath,omitempty"`
}

func (s SchemasResolved) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SchemasResolved) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *SchemasResolved) GetDataPath() *string {
	if o == nil {
		return nil
	}
	return o.DataPath
}

type SchemasExtensionHookCostDataRetrievalType string

const (
	SchemasExtensionHookCostDataRetrievalTypeCostDataRetrieval SchemasExtensionHookCostDataRetrievalType = "costDataRetrieval"
)

func (e SchemasExtensionHookCostDataRetrievalType) ToPointer() *SchemasExtensionHookCostDataRetrievalType {
	return &e
}
func (e *SchemasExtensionHookCostDataRetrievalType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "costDataRetrieval":
		*e = SchemasExtensionHookCostDataRetrievalType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SchemasExtensionHookCostDataRetrievalType: %v", v)
	}
}

// ExtensionHookCostDataRetrievalSchemas - Hook that will allow using the specified source as data for consumption visualizations. This hook is triggered to fetch the data. Format of the request and response has to follow the following specification: TBD. The expected response to the call is:
//
//   - 200 with the time series data
type ExtensionHookCostDataRetrievalSchemas struct {
	Auth *ExtensionAuthBlock                       `json:"auth,omitempty"`
	Call SchemasExtensionHookCostDataRetrievalCall `json:"call"`
	// Identifier of the hook. Should not change between updates.
	ID       *string                                   `json:"id,omitempty"`
	Resolved *SchemasResolved                          `json:"resolved,omitempty"`
	Type     SchemasExtensionHookCostDataRetrievalType `json:"type"`
}

func (e ExtensionHookCostDataRetrievalSchemas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ExtensionHookCostDataRetrievalSchemas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"call", "type"}); err != nil {
		return err
	}
	return nil
}

func (o *ExtensionHookCostDataRetrievalSchemas) GetAuth() *ExtensionAuthBlock {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ExtensionHookCostDataRetrievalSchemas) GetCall() SchemasExtensionHookCostDataRetrievalCall {
	if o == nil {
		return SchemasExtensionHookCostDataRetrievalCall{}
	}
	return o.Call
}

func (o *ExtensionHookCostDataRetrievalSchemas) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *ExtensionHookCostDataRetrievalSchemas) GetResolved() *SchemasResolved {
	if o == nil {
		return nil
	}
	return o.Resolved
}

func (o *ExtensionHookCostDataRetrievalSchemas) GetType() SchemasExtensionHookCostDataRetrievalType {
	if o == nil {
		return SchemasExtensionHookCostDataRetrievalType("")
	}
	return o.Type
}

type Call struct {
	// Request body to send. Supports variable interpolation. Content format is determined by Content-Type header.
	Body map[string]string `json:"body,omitempty"`
	// Headers to use. Supports variable interpolation.
	Headers map[string]string `json:"headers,omitempty"`
	// HTTP method to use for the call
	Method *string `default:"GET" json:"method"`
	// Parameters to append to the URL. Supports variable interpolation.
	Params map[string]string `json:"params,omitempty"`
	// URL to call. Supports variable interpolation.
	URL string `json:"url"`
}

func (c Call) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *Call) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"url"}); err != nil {
		return err
	}
	return nil
}

func (o *Call) GetBody() map[string]string {
	if o == nil {
		return nil
	}
	return o.Body
}

func (o *Call) GetHeaders() map[string]string {
	if o == nil {
		return nil
	}
	return o.Headers
}

func (o *Call) GetMethod() *string {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *Call) GetParams() map[string]string {
	if o == nil {
		return nil
	}
	return o.Params
}

func (o *Call) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

type Resolved struct {
	// Optional path to the data (array) in the response. If omitted, the data is assumed to be on the top level.
	DataPath *string `json:"dataPath,omitempty"`
}

func (r Resolved) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *Resolved) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *Resolved) GetDataPath() *string {
	if o == nil {
		return nil
	}
	return o.DataPath
}

type Type string

const (
	TypeConsumptionDataRetrieval Type = "consumptionDataRetrieval"
)

func (e Type) ToPointer() *Type {
	return &e
}
func (e *Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "consumptionDataRetrieval":
		*e = Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Type: %v", v)
	}
}

// Schemas - Hook that will allow using the specified source as data for consumption visualizations. This hook is triggered to fetch the data. Format of the request and response has to follow the following specification: TBD. The expected response to the call is:
//
//   - 200 with the time series data
type Schemas struct {
	Auth *ExtensionAuthBlock `json:"auth,omitempty"`
	Call Call                `json:"call"`
	// Identifier of the hook. Should not change between updates.
	ID       *string   `json:"id,omitempty"`
	Resolved *Resolved `json:"resolved,omitempty"`
	Type     Type      `json:"type"`
}

func (s Schemas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *Schemas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"call", "type"}); err != nil {
		return err
	}
	return nil
}

func (o *Schemas) GetAuth() *ExtensionAuthBlock {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *Schemas) GetCall() Call {
	if o == nil {
		return Call{}
	}
	return o.Call
}

func (o *Schemas) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Schemas) GetResolved() *Resolved {
	if o == nil {
		return nil
	}
	return o.Resolved
}

func (o *Schemas) GetType() Type {
	if o == nil {
		return Type("")
	}
	return o.Type
}

type SchemasExtensionHookPriceDataRetrievalCall struct {
	// Request body to send. Supports variable interpolation. Content format is determined by Content-Type header.
	Body map[string]string `json:"body,omitempty"`
	// Headers to use. Supports variable interpolation.
	Headers map[string]string `json:"headers,omitempty"`
	// HTTP method to use for the call
	Method *string `default:"GET" json:"method"`
	// Parameters to append to the URL. Supports variable interpolation.
	Params map[string]string `json:"params,omitempty"`
	// URL to call. Supports variable interpolation.
	URL string `json:"url"`
}

func (s SchemasExtensionHookPriceDataRetrievalCall) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SchemasExtensionHookPriceDataRetrievalCall) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"url"}); err != nil {
		return err
	}
	return nil
}

func (o *SchemasExtensionHookPriceDataRetrievalCall) GetBody() map[string]string {
	if o == nil {
		return nil
	}
	return o.Body
}

func (o *SchemasExtensionHookPriceDataRetrievalCall) GetHeaders() map[string]string {
	if o == nil {
		return nil
	}
	return o.Headers
}

func (o *SchemasExtensionHookPriceDataRetrievalCall) GetMethod() *string {
	if o == nil {
		return nil
	}
	return o.Method
}

func (o *SchemasExtensionHookPriceDataRetrievalCall) GetParams() map[string]string {
	if o == nil {
		return nil
	}
	return o.Params
}

func (o *SchemasExtensionHookPriceDataRetrievalCall) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

type SchemasExtensionHookPriceDataRetrievalResolved struct {
	// Optional path to the data (array) in the response. If omitted, the data is assumed to be on the top level.
	DataPath *string `json:"dataPath,omitempty"`
}

func (s SchemasExtensionHookPriceDataRetrievalResolved) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SchemasExtensionHookPriceDataRetrievalResolved) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *SchemasExtensionHookPriceDataRetrievalResolved) GetDataPath() *string {
	if o == nil {
		return nil
	}
	return o.DataPath
}

type SchemasExtensionHookPriceDataRetrievalType string

const (
	SchemasExtensionHookPriceDataRetrievalTypePriceDataRetrieval SchemasExtensionHookPriceDataRetrievalType = "priceDataRetrieval"
)

func (e SchemasExtensionHookPriceDataRetrievalType) ToPointer() *SchemasExtensionHookPriceDataRetrievalType {
	return &e
}
func (e *SchemasExtensionHookPriceDataRetrievalType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "priceDataRetrieval":
		*e = SchemasExtensionHookPriceDataRetrievalType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SchemasExtensionHookPriceDataRetrievalType: %v", v)
	}
}

// ExtensionHookPriceDataRetrievalSchemas - Hook that will allow using the specified source as data for price visualizations. This hook is triggered to fetch the data. Format of the request and response has to follow the following specification: TBD. The expected response to the call is:
//
//   - 200 with the time series data
type ExtensionHookPriceDataRetrievalSchemas struct {
	Auth *ExtensionAuthBlock                        `json:"auth,omitempty"`
	Call SchemasExtensionHookPriceDataRetrievalCall `json:"call"`
	// Identifier of the hook. Should not change between updates.
	ID       *string                                         `json:"id,omitempty"`
	Resolved *SchemasExtensionHookPriceDataRetrievalResolved `json:"resolved,omitempty"`
	Type     SchemasExtensionHookPriceDataRetrievalType      `json:"type"`
}

func (e ExtensionHookPriceDataRetrievalSchemas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ExtensionHookPriceDataRetrievalSchemas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"call", "type"}); err != nil {
		return err
	}
	return nil
}

func (o *ExtensionHookPriceDataRetrievalSchemas) GetAuth() *ExtensionAuthBlock {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ExtensionHookPriceDataRetrievalSchemas) GetCall() SchemasExtensionHookPriceDataRetrievalCall {
	if o == nil {
		return SchemasExtensionHookPriceDataRetrievalCall{}
	}
	return o.Call
}

func (o *ExtensionHookPriceDataRetrievalSchemas) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *ExtensionHookPriceDataRetrievalSchemas) GetResolved() *SchemasExtensionHookPriceDataRetrievalResolved {
	if o == nil {
		return nil
	}
	return o.Resolved
}

func (o *ExtensionHookPriceDataRetrievalSchemas) GetType() SchemasExtensionHookPriceDataRetrievalType {
	if o == nil {
		return SchemasExtensionHookPriceDataRetrievalType("")
	}
	return o.Type
}

type SchemasCall struct {
	// Headers to use. Supports variable interpolation.
	Headers map[string]string `json:"headers"`
	// Parameters to append to the URL. Supports variable interpolation.
	Params map[string]string `json:"params,omitempty"`
	// URL to call. Supports variable interpolation.
	URL string `json:"url"`
}

func (s SchemasCall) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SchemasCall) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"headers", "url"}); err != nil {
		return err
	}
	return nil
}

func (o *SchemasCall) GetHeaders() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Headers
}

func (o *SchemasCall) GetParams() map[string]string {
	if o == nil {
		return nil
	}
	return o.Params
}

func (o *SchemasCall) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

// Explanation of the hook.
type Explanation struct {
	AdditionalProperties map[string]string `additionalProperties:"true" json:"-"`
	// Explanation of the functionality shown to the end user.
	En string `json:"en"`
}

func (e Explanation) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *Explanation) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"en"}); err != nil {
		return err
	}
	return nil
}

func (o *Explanation) GetAdditionalProperties() map[string]string {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *Explanation) GetEn() string {
	if o == nil {
		return ""
	}
	return o.En
}

type SchemasType string

const (
	SchemasTypeContractIdentification SchemasType = "contractIdentification"
)

func (e SchemasType) ToPointer() *SchemasType {
	return &e
}
func (e *SchemasType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "contractIdentification":
		*e = SchemasType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SchemasType: %v", v)
	}
}

// ExtensionHookContractIdentificationSchemas - Hook that replaces the built-in contract identification for self-assignment. This hook makes a POST call whenever a user is trying to self-assign a contract to find the corresponding contract(s). The expected response to the call is:
//
//   - 200 if found with either:
//   - contract_id array
//   - contact_id string
//   - 404 if no contract is found
//
// If `contact_id` is provided in the response, Contracts are retrieved from this Contact. In that case, optionally, if you also specify `contact_relation_attribute`, the specified Contact attribute of the user performing the action will be modified to add the matched Contact.
type ExtensionHookContractIdentificationSchemas struct {
	Auth *ExtensionAuthBlock `json:"auth,omitempty"`
	Call SchemasCall         `json:"call"`
	// Name of the Contact attribute to update with the matched Contact ID. Must be a Contact relation attribute supporting multiple entities.
	ContactRelationAttribute *string `json:"contact_relation_attribute,omitempty"`
	// Explanation of the hook.
	Explanation *Explanation `json:"explanation,omitempty"`
	// Identifier of the hook. Should not change between updates.
	ID   *string     `json:"id,omitempty"`
	Type SchemasType `json:"type"`
}

func (e ExtensionHookContractIdentificationSchemas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ExtensionHookContractIdentificationSchemas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"call", "type"}); err != nil {
		return err
	}
	return nil
}

func (o *ExtensionHookContractIdentificationSchemas) GetAuth() *ExtensionAuthBlock {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ExtensionHookContractIdentificationSchemas) GetCall() SchemasCall {
	if o == nil {
		return SchemasCall{}
	}
	return o.Call
}

func (o *ExtensionHookContractIdentificationSchemas) GetContactRelationAttribute() *string {
	if o == nil {
		return nil
	}
	return o.ContactRelationAttribute
}

func (o *ExtensionHookContractIdentificationSchemas) GetExplanation() *Explanation {
	if o == nil {
		return nil
	}
	return o.Explanation
}

func (o *ExtensionHookContractIdentificationSchemas) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *ExtensionHookContractIdentificationSchemas) GetType() SchemasType {
	if o == nil {
		return SchemasType("")
	}
	return o.Type
}

type SchemasExtensionHookRegistrationIdentifiersCheckCall struct {
	// Headers to use. Supports variable interpolation.
	Headers map[string]string `json:"headers"`
	// Parameters to append to the URL. Supports variable interpolation.
	Params map[string]string `json:"params,omitempty"`
	// Contact ID usually retrieved from the response body, e.g. `{{"{{"}}CallResponse.data.contact_id}}`. Supports variable interpolation.
	Result string `json:"result"`
	// URL to call. Supports variable interpolation.
	URL string `json:"url"`
}

func (s SchemasExtensionHookRegistrationIdentifiersCheckCall) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SchemasExtensionHookRegistrationIdentifiersCheckCall) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"headers", "result", "url"}); err != nil {
		return err
	}
	return nil
}

func (o *SchemasExtensionHookRegistrationIdentifiersCheckCall) GetHeaders() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Headers
}

func (o *SchemasExtensionHookRegistrationIdentifiersCheckCall) GetParams() map[string]string {
	if o == nil {
		return nil
	}
	return o.Params
}

func (o *SchemasExtensionHookRegistrationIdentifiersCheckCall) GetResult() string {
	if o == nil {
		return ""
	}
	return o.Result
}

func (o *SchemasExtensionHookRegistrationIdentifiersCheckCall) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

type SchemasExtensionHookRegistrationIdentifiersCheckType string

const (
	SchemasExtensionHookRegistrationIdentifiersCheckTypeRegistrationIdentifiersCheck SchemasExtensionHookRegistrationIdentifiersCheckType = "registrationIdentifiersCheck"
)

func (e SchemasExtensionHookRegistrationIdentifiersCheckType) ToPointer() *SchemasExtensionHookRegistrationIdentifiersCheckType {
	return &e
}
func (e *SchemasExtensionHookRegistrationIdentifiersCheckType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "registrationIdentifiersCheck":
		*e = SchemasExtensionHookRegistrationIdentifiersCheckType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SchemasExtensionHookRegistrationIdentifiersCheckType: %v", v)
	}
}

// ExtensionHookRegistrationIdentifiersCheckSchemas - Hook that replaces the built-in registration identifiers check. This hook makes a POST call whenever a user is trying to register to find the corresponding contact. The expected response to the call is:
//
//   - 200 with contact id if exactly one contact is found
//   - 404 if no contact is found or more than contact is found
type ExtensionHookRegistrationIdentifiersCheckSchemas struct {
	Auth *ExtensionAuthBlock                                  `json:"auth,omitempty"`
	Call SchemasExtensionHookRegistrationIdentifiersCheckCall `json:"call"`
	// Identifier of the hook. Should not change between updates.
	ID   *string                                              `json:"id,omitempty"`
	Type SchemasExtensionHookRegistrationIdentifiersCheckType `json:"type"`
}

func (e ExtensionHookRegistrationIdentifiersCheckSchemas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ExtensionHookRegistrationIdentifiersCheckSchemas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"call", "type"}); err != nil {
		return err
	}
	return nil
}

func (o *ExtensionHookRegistrationIdentifiersCheckSchemas) GetAuth() *ExtensionAuthBlock {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ExtensionHookRegistrationIdentifiersCheckSchemas) GetCall() SchemasExtensionHookRegistrationIdentifiersCheckCall {
	if o == nil {
		return SchemasExtensionHookRegistrationIdentifiersCheckCall{}
	}
	return o.Call
}

func (o *ExtensionHookRegistrationIdentifiersCheckSchemas) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *ExtensionHookRegistrationIdentifiersCheckSchemas) GetType() SchemasExtensionHookRegistrationIdentifiersCheckType {
	if o == nil {
		return SchemasExtensionHookRegistrationIdentifiersCheckType("")
	}
	return o.Type
}

type HooksType string

const (
	HooksTypeExtensionHookRegistrationIdentifiersCheckSchemas  HooksType = "ExtensionHookRegistrationIdentifiersCheck_Schemas"
	HooksTypeExtensionHookContractIdentificationSchemas        HooksType = "ExtensionHookContractIdentification_Schemas"
	HooksTypeExtensionHookPriceDataRetrievalSchemas            HooksType = "ExtensionHookPriceDataRetrieval_Schemas"
	HooksTypeSchemas                                           HooksType = "Schemas"
	HooksTypeExtensionHookCostDataRetrievalSchemas             HooksType = "ExtensionHookCostDataRetrieval_Schemas"
	HooksTypeExtensionHookMeterReadingPlausibilityCheckSchemas HooksType = "ExtensionHookMeterReadingPlausibilityCheck_Schemas"
)

type Hooks struct {
	ExtensionHookRegistrationIdentifiersCheckSchemas  *ExtensionHookRegistrationIdentifiersCheckSchemas  `queryParam:"inline" name:"hooks"`
	ExtensionHookContractIdentificationSchemas        *ExtensionHookContractIdentificationSchemas        `queryParam:"inline" name:"hooks"`
	ExtensionHookPriceDataRetrievalSchemas            *ExtensionHookPriceDataRetrievalSchemas            `queryParam:"inline" name:"hooks"`
	Schemas                                           *Schemas                                           `queryParam:"inline" name:"hooks"`
	ExtensionHookCostDataRetrievalSchemas             *ExtensionHookCostDataRetrievalSchemas             `queryParam:"inline" name:"hooks"`
	ExtensionHookMeterReadingPlausibilityCheckSchemas *ExtensionHookMeterReadingPlausibilityCheckSchemas `queryParam:"inline" name:"hooks"`

	Type HooksType
}

func CreateHooksExtensionHookRegistrationIdentifiersCheckSchemas(extensionHookRegistrationIdentifiersCheckSchemas ExtensionHookRegistrationIdentifiersCheckSchemas) Hooks {
	typ := HooksTypeExtensionHookRegistrationIdentifiersCheckSchemas

	return Hooks{
		ExtensionHookRegistrationIdentifiersCheckSchemas: &extensionHookRegistrationIdentifiersCheckSchemas,
		Type: typ,
	}
}

func CreateHooksExtensionHookContractIdentificationSchemas(extensionHookContractIdentificationSchemas ExtensionHookContractIdentificationSchemas) Hooks {
	typ := HooksTypeExtensionHookContractIdentificationSchemas

	return Hooks{
		ExtensionHookContractIdentificationSchemas: &extensionHookContractIdentificationSchemas,
		Type: typ,
	}
}

func CreateHooksExtensionHookPriceDataRetrievalSchemas(extensionHookPriceDataRetrievalSchemas ExtensionHookPriceDataRetrievalSchemas) Hooks {
	typ := HooksTypeExtensionHookPriceDataRetrievalSchemas

	return Hooks{
		ExtensionHookPriceDataRetrievalSchemas: &extensionHookPriceDataRetrievalSchemas,
		Type:                                   typ,
	}
}

func CreateHooksSchemas(schemas Schemas) Hooks {
	typ := HooksTypeSchemas

	return Hooks{
		Schemas: &schemas,
		Type:    typ,
	}
}

func CreateHooksExtensionHookCostDataRetrievalSchemas(extensionHookCostDataRetrievalSchemas ExtensionHookCostDataRetrievalSchemas) Hooks {
	typ := HooksTypeExtensionHookCostDataRetrievalSchemas

	return Hooks{
		ExtensionHookCostDataRetrievalSchemas: &extensionHookCostDataRetrievalSchemas,
		Type:                                  typ,
	}
}

func CreateHooksExtensionHookMeterReadingPlausibilityCheckSchemas(extensionHookMeterReadingPlausibilityCheckSchemas ExtensionHookMeterReadingPlausibilityCheckSchemas) Hooks {
	typ := HooksTypeExtensionHookMeterReadingPlausibilityCheckSchemas

	return Hooks{
		ExtensionHookMeterReadingPlausibilityCheckSchemas: &extensionHookMeterReadingPlausibilityCheckSchemas,
		Type: typ,
	}
}

func (u *Hooks) UnmarshalJSON(data []byte) error {

	var extensionHookMeterReadingPlausibilityCheckSchemas ExtensionHookMeterReadingPlausibilityCheckSchemas = ExtensionHookMeterReadingPlausibilityCheckSchemas{}
	if err := utils.UnmarshalJSON(data, &extensionHookMeterReadingPlausibilityCheckSchemas, "", true, nil); err == nil {
		u.ExtensionHookMeterReadingPlausibilityCheckSchemas = &extensionHookMeterReadingPlausibilityCheckSchemas
		u.Type = HooksTypeExtensionHookMeterReadingPlausibilityCheckSchemas
		return nil
	}

	var extensionHookRegistrationIdentifiersCheckSchemas ExtensionHookRegistrationIdentifiersCheckSchemas = ExtensionHookRegistrationIdentifiersCheckSchemas{}
	if err := utils.UnmarshalJSON(data, &extensionHookRegistrationIdentifiersCheckSchemas, "", true, nil); err == nil {
		u.ExtensionHookRegistrationIdentifiersCheckSchemas = &extensionHookRegistrationIdentifiersCheckSchemas
		u.Type = HooksTypeExtensionHookRegistrationIdentifiersCheckSchemas
		return nil
	}

	var extensionHookContractIdentificationSchemas ExtensionHookContractIdentificationSchemas = ExtensionHookContractIdentificationSchemas{}
	if err := utils.UnmarshalJSON(data, &extensionHookContractIdentificationSchemas, "", true, nil); err == nil {
		u.ExtensionHookContractIdentificationSchemas = &extensionHookContractIdentificationSchemas
		u.Type = HooksTypeExtensionHookContractIdentificationSchemas
		return nil
	}

	var extensionHookPriceDataRetrievalSchemas ExtensionHookPriceDataRetrievalSchemas = ExtensionHookPriceDataRetrievalSchemas{}
	if err := utils.UnmarshalJSON(data, &extensionHookPriceDataRetrievalSchemas, "", true, nil); err == nil {
		u.ExtensionHookPriceDataRetrievalSchemas = &extensionHookPriceDataRetrievalSchemas
		u.Type = HooksTypeExtensionHookPriceDataRetrievalSchemas
		return nil
	}

	var schemas Schemas = Schemas{}
	if err := utils.UnmarshalJSON(data, &schemas, "", true, nil); err == nil {
		u.Schemas = &schemas
		u.Type = HooksTypeSchemas
		return nil
	}

	var extensionHookCostDataRetrievalSchemas ExtensionHookCostDataRetrievalSchemas = ExtensionHookCostDataRetrievalSchemas{}
	if err := utils.UnmarshalJSON(data, &extensionHookCostDataRetrievalSchemas, "", true, nil); err == nil {
		u.ExtensionHookCostDataRetrievalSchemas = &extensionHookCostDataRetrievalSchemas
		u.Type = HooksTypeExtensionHookCostDataRetrievalSchemas
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Hooks", string(data))
}

func (u Hooks) MarshalJSON() ([]byte, error) {
	if u.ExtensionHookRegistrationIdentifiersCheckSchemas != nil {
		return utils.MarshalJSON(u.ExtensionHookRegistrationIdentifiersCheckSchemas, "", true)
	}

	if u.ExtensionHookContractIdentificationSchemas != nil {
		return utils.MarshalJSON(u.ExtensionHookContractIdentificationSchemas, "", true)
	}

	if u.ExtensionHookPriceDataRetrievalSchemas != nil {
		return utils.MarshalJSON(u.ExtensionHookPriceDataRetrievalSchemas, "", true)
	}

	if u.Schemas != nil {
		return utils.MarshalJSON(u.Schemas, "", true)
	}

	if u.ExtensionHookCostDataRetrievalSchemas != nil {
		return utils.MarshalJSON(u.ExtensionHookCostDataRetrievalSchemas, "", true)
	}

	if u.ExtensionHookMeterReadingPlausibilityCheckSchemas != nil {
		return utils.MarshalJSON(u.ExtensionHookMeterReadingPlausibilityCheckSchemas, "", true)
	}

	return nil, errors.New("could not marshal union type Hooks: all fields are null")
}

// Name of the extension.
type Name struct {
	AdditionalProperties map[string]string `additionalProperties:"true" json:"-"`
	// Name of the extension in English.
	En string `json:"en"`
}

func (n Name) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *Name) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, []string{"en"}); err != nil {
		return err
	}
	return nil
}

func (o *Name) GetAdditionalProperties() map[string]string {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *Name) GetEn() string {
	if o == nil {
		return ""
	}
	return o.En
}

// ExtensionDescription - Description of the option.
type ExtensionDescription struct {
	AdditionalProperties map[string]string `additionalProperties:"true" json:"-"`
	// Description of the option in English.
	En string `json:"en"`
}

func (e ExtensionDescription) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ExtensionDescription) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"en"}); err != nil {
		return err
	}
	return nil
}

func (o *ExtensionDescription) GetAdditionalProperties() map[string]string {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *ExtensionDescription) GetEn() string {
	if o == nil {
		return ""
	}
	return o.En
}

// ExtensionName - Name of the option.
type ExtensionName struct {
	AdditionalProperties map[string]string `additionalProperties:"true" json:"-"`
	// Name of the option in English.
	En string `json:"en"`
}

func (e ExtensionName) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ExtensionName) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"en"}); err != nil {
		return err
	}
	return nil
}

func (o *ExtensionName) GetAdditionalProperties() map[string]string {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}

func (o *ExtensionName) GetEn() string {
	if o == nil {
		return ""
	}
	return o.En
}

// ExtensionType - Type of the option.
type ExtensionType string

const (
	ExtensionTypeText   ExtensionType = "text"
	ExtensionTypeSecret ExtensionType = "secret"
)

func (e ExtensionType) ToPointer() *ExtensionType {
	return &e
}
func (e *ExtensionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "text":
		fallthrough
	case "secret":
		*e = ExtensionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ExtensionType: %v", v)
	}
}

type OptionsObj struct {
	// Default value of the option.
	Default *string `json:"default,omitempty"`
	// Description of the option.
	Description *ExtensionDescription `json:"description,omitempty"`
	// Identifier of the option. Should not change between updates.
	ID string `json:"id"`
	// Name of the option.
	Name ExtensionName `json:"name"`
	// Indicate whether the option is required.
	Required *bool `default:"false" json:"required"`
	// Type of the option.
	Type ExtensionType `json:"type"`
}

func (o OptionsObj) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OptionsObj) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, []string{"id", "name", "type"}); err != nil {
		return err
	}
	return nil
}

func (o *OptionsObj) GetDefault() *string {
	if o == nil {
		return nil
	}
	return o.Default
}

func (o *OptionsObj) GetDescription() *ExtensionDescription {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *OptionsObj) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *OptionsObj) GetName() ExtensionName {
	if o == nil {
		return ExtensionName{}
	}
	return o.Name
}

func (o *OptionsObj) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *OptionsObj) GetType() ExtensionType {
	if o == nil {
		return ExtensionType("")
	}
	return o.Type
}

type Extension struct {
	// Identifier of the app from which the extension was installed. Should not change between updates.
	AppID *string `json:"app_id,omitempty"`
	// Name of the extension.
	Description *Description `json:"description,omitempty"`
	// Hooks that influence the behavior of Portal.
	Hooks []Hooks `json:"hooks,omitempty"`
	// Identifier of the extension. Should not change between updates.
	ID string `json:"id"`
	// External links added to the portal.
	Links []ExtensionSeamlessLink `json:"links,omitempty"`
	// Name of the extension.
	Name Name `json:"name"`
	// Options available to the extension configurable by the portal administrator.
	Options []OptionsObj `json:"options,omitempty"`
	// Version of the extension.
	Version *string `json:"version,omitempty"`
}

func (o *Extension) GetAppID() *string {
	if o == nil {
		return nil
	}
	return o.AppID
}

func (o *Extension) GetDescription() *Description {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *Extension) GetHooks() []Hooks {
	if o == nil {
		return nil
	}
	return o.Hooks
}

func (o *Extension) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *Extension) GetLinks() []ExtensionSeamlessLink {
	if o == nil {
		return nil
	}
	return o.Links
}

func (o *Extension) GetName() Name {
	if o == nil {
		return Name{}
	}
	return o.Name
}

func (o *Extension) GetOptions() []OptionsObj {
	if o == nil {
		return nil
	}
	return o.Options
}

func (o *Extension) GetVersion() *string {
	if o == nil {
		return nil
	}
	return o.Version
}
